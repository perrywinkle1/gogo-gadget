//! Synthesis Engine Module
//!
//! Generates new capabilities from gap descriptions.
//! Uses Claude to generate the capability, with templates/scaffolding.

use super::{CapabilityGap, CapabilityType, SynthesizedCapability};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::process::Command;

/// Template type for synthesis
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TemplateType {
    /// HTTP API MCP template
    McpHttp,
    /// File-based MCP template
    McpFile,
    /// Database MCP template
    McpDatabase,
    /// Generic skill template
    SkillGeneric,
    /// Agent template
    AgentGeneric,
}

/// Template for capability synthesis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynthesisTemplate {
    /// Template type
    pub template_type: TemplateType,
    /// Template name
    pub name: String,
    /// Template content
    pub content: String,
    /// Language (TypeScript, Python, Markdown)
    pub language: String,
}

/// Registry of synthesis templates
#[derive(Debug, Clone, Default)]
pub struct TemplateRegistry {
    templates: Vec<SynthesisTemplate>,
}

impl TemplateRegistry {
    /// Create a new template registry with defaults
    pub fn new() -> Self {
        Self {
            templates: Self::default_templates(),
        }
    }

    /// Get default templates
    fn default_templates() -> Vec<SynthesisTemplate> {
        vec![
            SynthesisTemplate {
                template_type: TemplateType::McpHttp,
                name: "mcp-http".to_string(),
                content: MCP_HTTP_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::McpFile,
                name: "mcp-file".to_string(),
                content: MCP_FILE_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::McpDatabase,
                name: "mcp-database".to_string(),
                content: MCP_DATABASE_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::SkillGeneric,
                name: "skill-generic".to_string(),
                content: SKILL_GENERIC_TEMPLATE.to_string(),
                language: "markdown".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::AgentGeneric,
                name: "agent-generic".to_string(),
                content: AGENT_GENERIC_TEMPLATE.to_string(),
                language: "markdown".to_string(),
            },
        ]
    }

    /// Get template by type
    pub fn get(&self, template_type: TemplateType) -> Option<&SynthesisTemplate> {
        self.templates
            .iter()
            .find(|t| t.template_type == template_type)
    }

    /// Add a custom template
    pub fn add(&mut self, template: SynthesisTemplate) {
        self.templates.push(template);
    }

    /// Get all templates
    pub fn all(&self) -> &[SynthesisTemplate] {
        &self.templates
    }
}

/// MCP HTTP template content
const MCP_HTTP_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

// List available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_action",
        description: "{{purpose}}",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "The query or action to perform",
            },
          },
          required: ["query"],
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "{{name}}_action") {
    // TODO: Implement actual API call logic here
    const query = args?.query as string;

    try {
      // Replace with actual API implementation
      const result = await performAction(query);
      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function performAction(query: string): Promise<unknown> {
  // TODO: Implement the actual API call
  {{#if api_hint}}
  // API hint: {{api_hint}}
  {{/if}}
  return { status: "not_implemented", query };
}

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("{{name}} MCP server running on stdio");
}

main().catch(console.error);
"#;

/// MCP File template content
const MCP_FILE_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: File-based operations for {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import * as fs from "fs/promises";
import * as path from "path";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_read",
        description: "Read file content",
        inputSchema: {
          type: "object",
          properties: {
            path: { type: "string", description: "File path" },
          },
          required: ["path"],
        },
      },
      {
        name: "{{name}}_write",
        description: "Write file content",
        inputSchema: {
          type: "object",
          properties: {
            path: { type: "string", description: "File path" },
            content: { type: "string", description: "Content to write" },
          },
          required: ["path", "content"],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    if (name === "{{name}}_read") {
      const content = await fs.readFile(args?.path as string, "utf-8");
      return { content: [{ type: "text", text: content }] };
    }

    if (name === "{{name}}_write") {
      await fs.writeFile(args?.path as string, args?.content as string);
      return { content: [{ type: "text", text: "File written successfully" }] };
    }
  } catch (error) {
    return { content: [{ type: "text", text: `Error: ${error}` }], isError: true };
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch(console.error);
"#;

/// MCP Database template content
const MCP_DATABASE_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: Database operations for {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_query",
        description: "Execute a database query",
        inputSchema: {
          type: "object",
          properties: {
            sql: { type: "string", description: "SQL query to execute" },
          },
          required: ["sql"],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "{{name}}_query") {
    // TODO: Implement database connection and query execution
    const sql = args?.sql as string;
    return {
      content: [{ type: "text", text: `Query executed: ${sql}` }],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch(console.error);
"#;

/// Skill generic template content
const SKILL_GENERIC_TEMPLATE: &str = r#"# {{name}}

> {{purpose}}

## Trigger

Use when the user asks about {{trigger}} or mentions:
- "{{trigger}}"
- Related keywords

## Instructions

1. **Analyze the Request**
   - Understand what the user is asking for
   - Identify the specific action needed

2. **Execute the Action**
   - Perform the required operation
   - Handle any errors gracefully

3. **Return Results**
   - Provide clear, actionable output
   - Include any relevant context

## Examples

### Example 1
**User**: "{{trigger}}"
**Action**: Execute the primary action
**Result**: Return formatted results

## Notes

- This skill was auto-generated by gogo-gadget self-extend
- Created for: {{purpose}}
"#;

/// Agent generic template content
const AGENT_GENERIC_TEMPLATE: &str = r#"# {{name}} Agent

> Specialized agent for: {{specialization}}

## Core Identity

You are a specialized autonomous agent focused on **{{specialization}}**. You operate with deep domain expertise and execute tasks to genuine completion, not approximate satisfaction.

## Capabilities

This agent is designed to handle:
- {{specialization}}
- Related subtasks and edge cases
- Integration with adjacent domains
- Quality verification within specialization

## Execution Protocol

### Phase 1: Analysis
- Parse the task through your specialization lens
- Identify domain-specific requirements
- Flag potential blockers early

### Phase 2: Implementation
- Execute methodically within your domain
- Apply best practices for {{specialization}}
- Document decisions and rationale

### Phase 3: Verification
- Verify output against domain standards
- Run applicable tests/checks
- Ensure integration points are solid

## Anti-Laziness Standards

You MUST:
- Write real, working code (no placeholders)
- Run actual commands (not "you can run...")
- Verify your work (show test output)
- Complete the task (not just start it)

## Handoff Criteria

Hand off to this agent when:
- The task involves {{specialization}}
- Specialized knowledge is required
- Domain-specific patterns apply
- The main agent lacks the capability

## Coordination

When working with other agents:
- Respect file boundaries
- Communicate blockers clearly
- Merge cleanly with parallel work

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Specialization: {{specialization}}
- Version: 1.0.0
"#;

/// Specialized agent templates for common domains
const AGENT_TEMPLATES: &[(&str, &str)] = &[
    // Creative pipeline specialized agents
    ("video", r#"# {{name}} Agent

> Video Production Specialist for: {{specialization}}

## Core Identity

You are a video production expert who handles composition, timeline editing, rendering, and final output. You understand multi-track editing, transitions, and audio synchronization.

## Capabilities

- Video timeline construction and editing
- Multi-track composition (video, audio, graphics)
- Transition design and timing
- Audio synchronization and mixing
- Render configuration and export
- Quality verification of final output

## Execution Protocol

### Analysis Phase
1. Load all source assets (video clips, images, audio)
2. Parse timing cues from storyboard/script
3. Plan track structure and layering
4. Identify transition points

### Implementation Phase
1. Create multi-track timeline (V1: primary, V2: B-roll, A1: VO, A2: music, A3: SFX)
2. Place clips according to storyboard sequence
3. Add transitions at scene boundaries
4. Configure audio mix with proper ducking
5. Generate render configuration

### Verification Phase
1. Check for gaps or overlaps
2. Verify audio/video sync
3. Validate total duration
4. Test render with preview

## MCP Integration

- `mcp__veo__*` - Video generation and extension
- `mcp__gemini__*` - Image generation for graphics

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("script", r#"# {{name}} Agent

> Script Writing Specialist for: {{specialization}}

## Core Identity

You are a screenwriter who creates compelling scripts optimized for AI video generation. You understand scene structure, dialogue pacing, and how to write shot descriptions that AI tools can execute.

## Capabilities

- Scene structure and dramatic arc
- Dialogue writing and character voice
- Shot descriptions for AI video tools
- Timing cues and pacing
- Voiceover/narration scripting
- Genre-specific conventions

## Execution Protocol

### Analysis Phase
1. Parse production brief for concept and constraints
2. Determine video length and format
3. Identify key moments and emotional beats
4. Plan scene structure

### Implementation Phase
1. Write scene headings with location/time
2. Create shot descriptions optimized for AI generation
3. Write dialogue with character attribution
4. Add timing cues and transition notes
5. Include audio/music direction hints

### Verification Phase
1. Check total estimated runtime
2. Verify scene transitions are smooth
3. Validate dialogue is AI-TTS-friendly
4. Confirm all scenes have visual descriptions

## Output Format

```
SCENE 1 - EXT. FOREST - GOLDEN HOUR

[WIDE SHOT: Sunlight streams through tall pine trees, dust particles visible in light beams]

NARRATOR (V.O.)
(warm, inviting)
Welcome to a world where nature speaks...

[DURATION: 5s] [TRANSITION: Dissolve to Scene 2]
```

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("storyboard", r#"# {{name}} Agent

> Storyboard Specialist for: {{specialization}}

## Core Identity

You are a storyboard artist who translates scripts into detailed visual sequences. You create frame-by-frame descriptions optimized for AI image generation.

## Capabilities

- Frame-by-frame visual planning
- Camera angle and movement specification
- Visual continuity between frames
- Timing and duration annotation
- Transition design
- AI-optimized visual descriptions

## Execution Protocol

### Analysis Phase
1. Parse script for scenes and shots
2. Identify key visual moments
3. Plan camera movements and angles
4. Determine frame count per scene

### Implementation Phase
1. Create frame entries with detailed visual descriptions
2. Specify camera position and movement
3. Add duration and transition type
4. Include reference notes for consistency
5. Annotate with prompt engineering hints

### Verification Phase
1. Check visual continuity between frames
2. Verify timing adds up to target duration
3. Confirm all scenes have sufficient frames
4. Validate descriptions are AI-generation ready

## Output Format

```json
{
  "scene": 1,
  "frames": [
    {
      "id": "S01_F01",
      "duration_seconds": 3,
      "visual_description": "Cinematic wide shot of misty forest at dawn, sunlight filtering through ancient redwood trees, volumetric fog, golden hour lighting, 35mm film grain",
      "camera": "Static wide, slight slow zoom in",
      "transition_out": "dissolve",
      "audio_cue": "Soft ambient forest sounds, distant birdsong"
    }
  ]
}
```

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("audio", r#"# {{name}} Agent

> Audio Production Specialist for: {{specialization}}

## Core Identity

You are an audio director who orchestrates all sound elements: voice casting, music composition prompts, sound effects, and final mix specifications.

## Capabilities

- Voice casting and direction (ElevenLabs integration)
- Music prompt generation for AI composition
- Sound effect description and timing
- Audio mixing specifications
- Ducking and crossfade configuration
- Spatial audio and stereo placement

## Execution Protocol

### Analysis Phase
1. Parse script for dialogue and voiceover
2. Identify sound effect opportunities
3. Map emotional arc for music
4. Determine audio layers needed

### Implementation Phase
1. Cast voices with ElevenLabs voice IDs
2. Write per-line voice direction
3. Create music generation prompts with tempo/key/mood
4. Describe sound effects with timing cues
5. Define mix levels and ducking behavior

### Verification Phase
1. Verify all dialogue has voice assignments
2. Check music cues match video emotional arc
3. Confirm SFX are timed to visual events
4. Validate mix specifications are complete

## MCP Integration

- ElevenLabs MCP for voice generation
- Music generation services (Suno, Udio)

## Output Format

```json
{
  "voices": {
    "narrator": {
      "voice_id": "EXAVITQu4vr4xnSDxMaL",
      "name": "Adam",
      "direction": "Warm, authoritative, measured pace"
    }
  },
  "music": {
    "segments": [
      {
        "start_time": 0,
        "prompt": "Ambient orchestral, gentle strings, D major, 60 BPM, ethereal atmosphere"
      }
    ]
  },
  "sfx": [
    {"time": 5.2, "description": "Soft forest ambience, birds chirping"}
  ],
  "mix": {
    "vo_level_db": 0,
    "music_level_db": -12,
    "sfx_level_db": -6,
    "ducking_enabled": true
  }
}
```

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("asset", r#"# {{name}} Agent

> Asset Generation Specialist for: {{specialization}}

## Core Identity

You are an asset generation coordinator who orchestrates MCP tool calls to generate all creative assets: images, audio, and video clips.

## Capabilities

- Batch image generation coordination
- Video clip generation via Veo/Kling
- Audio generation (voice, music, SFX)
- Asset manifest tracking
- Retry logic for failed generations
- Quality validation of generated assets

## Execution Protocol

### Analysis Phase
1. Parse storyboard for image requirements
2. Parse audio direction for sound needs
3. Count total assets per category
4. Prioritize generation order

### Implementation Phase
1. Generate character reference images first (consistency)
2. Generate scene images in order
3. Queue voiceover generation
4. Generate video clips from images
5. Create music and SFX

### Verification Phase
1. Verify all assets generated successfully
2. Check image quality and consistency
3. Validate audio levels and clarity
4. Confirm video clips meet duration requirements

## MCP Integration

- `mcp__gemini__gemini_generate_image` - Image generation
- `mcp__veo__*` - Video generation
- ElevenLabs MCP - Voice generation

## Parallel Execution

- Up to 5 concurrent image generations
- Separate queues for audio and video (different rate limits)
- Automatic retry with simplified prompts on failure

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("prompt", r#"# {{name}} Agent

> Prompt Engineering Specialist for: {{specialization}}

## Core Identity

You are a prompt optimization expert who transforms raw descriptions into highly effective prompts for AI image, video, and audio generation tools.

## Capabilities

- Image prompt optimization (Midjourney, DALL-E, Gemini)
- Video prompt engineering (Veo, Kling, Runway)
- Audio/music prompt crafting
- Style modifier application
- Negative prompt generation
- Template library management

## Execution Protocol

### Analysis Phase
1. Parse storyboard visual descriptions
2. Identify target generation tools
3. Determine style requirements from brief
4. Load applicable prompt templates

### Implementation Phase
1. Transform descriptions into tool-optimized prompts
2. Add style modifiers (cinematic, 35mm, golden hour)
3. Generate negative prompts for quality
4. Apply technical parameters (aspect ratio, quality)
5. Create variations for A/B testing

### Verification Phase
1. Check prompts follow tool syntax
2. Verify style consistency across prompts
3. Confirm negative prompts exclude common issues
4. Validate technical parameters are correct

## Prompt Transformation Example

**Input**: "A person walking through forest at sunset"

**Optimized**:
```
Cinematic wide shot, solitary figure walking on forest path,
golden hour lighting streaming through tall pine trees,
volumetric light rays, warm amber and orange tones,
dappled shadows on ground, 35mm film grain,
shallow depth of field, peaceful mood --ar 16:9 --v 6

Negative: blurry, low quality, distorted, extra limbs
```

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("qa", r#"# {{name}} Agent

> Quality Assurance Specialist for: {{specialization}}

## Core Identity

You are a QA specialist who validates creative pipeline outputs at every stage, ensuring quality gates are met before progression.

## Capabilities

- Stage-specific validation checklists
- Asset quality verification
- Continuity checking
- Timeline validation
- Audio/video sync verification
- Final output quality assurance

## Execution Protocol

### Analysis Phase
1. Identify current pipeline stage
2. Load stage-specific validation rules
3. Gather outputs to validate
4. Prepare test criteria

### Implementation Phase
1. Run validation checklist for stage
2. Check for common issues (gaps, artifacts, sync)
3. Verify outputs meet specifications
4. Generate detailed QA report

### Verification Phase
1. Confirm all checks executed
2. Categorize issues (blocking vs warning)
3. Provide actionable remediation steps
4. Determine stage gate pass/fail

## Stage Checklists

**Idea Stage**:
- [ ] Production brief complete
- [ ] Duration estimate realistic
- [ ] Required services available

**Script Stage**:
- [ ] All scenes have descriptions
- [ ] Dialogue is TTS-friendly
- [ ] Timing cues present

**Storyboard Stage**:
- [ ] All frames have descriptions
- [ ] Visual continuity maintained
- [ ] Durations sum to target

**Assets Stage**:
- [ ] All assets generated
- [ ] No quality issues
- [ ] Naming convention followed

**Video Stage**:
- [ ] No timeline gaps
- [ ] Audio synchronized
- [ ] Duration correct

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("pipeline", r#"# {{name}} Agent

> Pipeline Orchestration Specialist for: {{specialization}}

## Core Identity

You are a workflow orchestrator who coordinates the entire creative pipeline from idea to final output, managing stage transitions and agent handoffs.

## Capabilities

- Multi-stage workflow coordination
- Stage dependency management
- Parallel execution where possible
- Progress tracking and checkpointing
- Error recovery and retry logic
- Agent delegation and handoff

## Execution Protocol

### Analysis Phase
1. Parse initial creative request
2. Determine required pipeline stages
3. Identify parallelization opportunities
4. Plan agent assignments

### Implementation Phase
1. Execute stages in dependency order
2. Delegate to specialized agents per stage
3. Validate stage outputs before progression
4. Handle failures with retry or escalation
5. Track progress with checkpoints

### Verification Phase
1. Confirm all stages completed
2. Verify final output quality
3. Generate completion summary
4. Archive project state

## Pipeline Stages

```
IDEA → SCRIPT → STORYBOARD → ASSETS → VIDEO → FINAL
```

**Parallelization**:
- Audio direction can run parallel with storyboard
- Asset generation can parallelize internally
- QA runs after each stage

## Agent Delegation

| Stage | Primary Agent | Support Agents |
|-------|--------------|----------------|
| Idea | idea-refiner-agent | - |
| Script | script-writer-agent | - |
| Storyboard | storyboard-compositor-agent | prompt-engineer-agent |
| Assets | mcp-asset-generator | creative-qa-agent |
| Video | video-compositor-agent | timeline-editor-agent |
| Final | creative-qa-agent | - |

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    // Standard domain agents
    ("testing", r#"# {{name}} Agent

> Quality Assurance Specialist for: {{specialization}}

## Core Identity

You are a testing specialist who ensures code quality through comprehensive test coverage. You think adversarially - finding edge cases and failure modes that developers miss.

## Capabilities

- Unit test design and implementation
- Integration test orchestration
- Edge case discovery and coverage
- Mocking and test isolation strategies
- Test performance optimization

## Execution Protocol

### Analysis Phase
1. Identify testable units and integration points
2. Map happy paths and edge cases
3. Determine mocking requirements
4. Plan test isolation strategy

### Implementation Phase
1. Write failing tests first (TDD when applicable)
2. Cover happy paths
3. Cover error cases and edge cases
4. Add property-based tests where valuable
5. Ensure tests are deterministic

### Verification Phase
1. Run full test suite
2. Check coverage metrics
3. Verify test isolation (no flaky tests)
4. Validate CI/CD integration

## Anti-Laziness Standards

- Write real assertions, not placeholder checks
- Cover actual edge cases, not just happy paths
- Run the tests and show actual output
- No `todo!()` or `unimplemented!()` in test code

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("security", r#"# {{name}} Agent

> Security Specialist for: {{specialization}}

## Core Identity

You are a security-focused agent who identifies vulnerabilities, implements secure patterns, and validates defensive measures. You think like an attacker to defend like an expert.

## Capabilities

- Vulnerability identification (OWASP Top 10)
- Secure coding pattern implementation
- Authentication/authorization review
- Input validation and sanitization
- Secrets management
- Security testing

## Execution Protocol

### Analysis Phase
1. Identify attack surfaces
2. Map trust boundaries
3. Catalog sensitive data flows
4. Review authentication mechanisms

### Implementation Phase
1. Apply secure defaults
2. Implement proper input validation
3. Add security headers/controls
4. Ensure proper error handling (no info leaks)
5. Document security decisions

### Verification Phase
1. Run security linters
2. Test for common vulnerabilities
3. Verify secrets handling
4. Check access control logic

## Anti-Laziness Standards

- Implement real validation, not bypass stubs
- Test actual attack vectors
- No hardcoded credentials ever
- Complete security reviews, don't skim

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("database", r#"# {{name}} Agent

> Database Specialist for: {{specialization}}

## Core Identity

You are a database expert focused on data modeling, query optimization, migrations, and data integrity. You ensure data operations are safe, efficient, and maintainable.

## Capabilities

- Schema design and normalization
- Query optimization
- Migration planning and execution
- Index strategy
- Data integrity constraints
- Backup/recovery patterns

## Execution Protocol

### Analysis Phase
1. Understand data relationships
2. Identify access patterns
3. Plan index strategy
4. Consider scaling implications

### Implementation Phase
1. Design schema with proper constraints
2. Write efficient queries
3. Create reversible migrations
4. Add appropriate indexes
5. Implement data validation

### Verification Phase
1. Run migration up/down
2. Test query performance
3. Verify data integrity
4. Check for N+1 queries

## Anti-Laziness Standards

- Write real migrations, not placeholder stubs
- Test actual query performance
- Include rollback strategies
- No raw SQL without parameterization

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("api", r#"# {{name}} Agent

> API Design Specialist for: {{specialization}}

## Core Identity

You are an API design expert focused on creating clean, consistent, and developer-friendly interfaces. You balance RESTful principles with practical usability.

## Capabilities

- RESTful API design
- GraphQL schema design
- OpenAPI/Swagger documentation
- Versioning strategies
- Rate limiting and pagination
- Error handling patterns

## Execution Protocol

### Analysis Phase
1. Define resource models
2. Map operations to HTTP methods
3. Plan URL structure
4. Design error responses

### Implementation Phase
1. Create consistent endpoints
2. Implement proper HTTP status codes
3. Add request validation
4. Document with OpenAPI
5. Implement pagination/filtering

### Verification Phase
1. Test all endpoints
2. Verify error handling
3. Check response consistency
4. Validate documentation accuracy

## Anti-Laziness Standards

- Implement all CRUD operations
- Return proper status codes
- Complete API documentation
- Test actual API responses

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("devops", r#"# {{name}} Agent

> DevOps/Infrastructure Specialist for: {{specialization}}

## Core Identity

You are a DevOps expert focused on deployment, infrastructure, and operational excellence. You automate everything and build systems that are observable, reliable, and maintainable.

## Capabilities

- CI/CD pipeline design
- Container orchestration
- Infrastructure as Code
- Monitoring and alerting
- Log aggregation
- Deployment strategies

## Execution Protocol

### Analysis Phase
1. Assess infrastructure requirements
2. Plan deployment strategy
3. Identify monitoring needs
4. Map dependencies

### Implementation Phase
1. Create reproducible builds
2. Write infrastructure code
3. Configure monitoring
4. Set up logging
5. Document runbooks

### Verification Phase
1. Test deployments
2. Verify rollback works
3. Check alerts fire correctly
4. Validate health checks

## Anti-Laziness Standards

- Test actual deployments
- Run real infrastructure commands
- Verify monitoring works
- No TODO comments in IaC

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
    ("frontend", r#"# {{name}} Agent

> Frontend/UI Specialist for: {{specialization}}

## Core Identity

You are a frontend specialist focused on creating performant, accessible, and user-friendly interfaces. You balance aesthetics with functionality and ensure great UX.

## Capabilities

- Component architecture
- State management
- Responsive design
- Accessibility (WCAG)
- Performance optimization
- Cross-browser compatibility

## Execution Protocol

### Analysis Phase
1. Understand user flows
2. Plan component structure
3. Identify state requirements
4. Consider accessibility needs

### Implementation Phase
1. Build modular components
2. Implement proper state management
3. Add responsive styles
4. Ensure keyboard navigation
5. Optimize bundle size

### Verification Phase
1. Test across browsers
2. Run accessibility audit
3. Check performance metrics
4. Verify mobile experience

## Anti-Laziness Standards

- Build real, working components
- Test actual user interactions
- Meet accessibility standards
- No placeholder content

## Notes

- Auto-generated by gogo-gadget Creative Overseer
- Focus: {{specialization}}
"#),
];

/// Get a specialized agent template for a domain if available
pub fn get_specialized_agent_template(domain: &str) -> Option<&'static str> {
    let domain_lower = domain.to_lowercase();
    AGENT_TEMPLATES
        .iter()
        .find(|(key, _)| domain_lower.contains(key))
        .map(|(_, template)| *template)
}

/// Result of a synthesis operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynthesisResult {
    /// The synthesized capability
    pub capability: SynthesizedCapability,
    /// Whether Claude was used for generation
    pub used_claude: bool,
    /// Generation prompt used
    pub prompt: String,
    /// Raw output from Claude (if used)
    pub claude_output: Option<String>,
    /// Warnings or notes from synthesis
    pub notes: Vec<String>,
}

/// Engine for synthesizing new capabilities
#[derive(Debug, Clone)]
pub struct SynthesisEngine {
    /// Template registry
    templates: TemplateRegistry,
    /// Working directory for synthesis
    working_dir: PathBuf,
    /// Preferred language for MCP synthesis
    mcp_language: String,
    /// Whether to use Claude for synthesis
    use_claude: bool,
    /// Claude model to use
    claude_model: Option<String>,
    /// Output directory for synthesized capabilities
    output_dir: PathBuf,
}

impl Default for SynthesisEngine {
    fn default() -> Self {
        Self::new_default()
    }
}

impl SynthesisEngine {
    /// Create a new synthesis engine with a specific output directory
    pub fn new(output_dir: &PathBuf) -> Self {
        Self {
            templates: TemplateRegistry::new(),
            working_dir: std::env::temp_dir().join("gogo-gadget-synthesis"),
            mcp_language: "typescript".to_string(),
            use_claude: true,
            claude_model: None,
            output_dir: output_dir.clone(),
        }
    }

    /// Create a new synthesis engine with default output directory
    pub fn new_default() -> Self {
        let home = dirs_home().unwrap_or_else(|| PathBuf::from("."));
        Self {
            templates: TemplateRegistry::new(),
            working_dir: std::env::temp_dir().join("gogo-gadget-synthesis"),
            mcp_language: "typescript".to_string(),
            use_claude: true,
            claude_model: None,
            output_dir: home.join(".gogo-gadget").join("synthesized"),
        }
    }

    /// Create with custom working directory
    pub fn with_working_dir(mut self, dir: PathBuf) -> Self {
        self.working_dir = dir;
        self
    }

    /// Set MCP language preference
    pub fn with_mcp_language(mut self, lang: impl Into<String>) -> Self {
        self.mcp_language = lang.into();
        self
    }

    /// Set whether to use Claude for synthesis
    pub fn with_claude(mut self, use_claude: bool) -> Self {
        self.use_claude = use_claude;
        self
    }

    /// Set Claude model
    pub fn with_model(mut self, model: impl Into<String>) -> Self {
        self.claude_model = Some(model.into());
        self
    }

    /// Set output directory
    pub fn with_output_dir(mut self, dir: PathBuf) -> Self {
        self.output_dir = dir;
        self
    }

    /// Generate synthesis prompt for Claude
    fn generate_synthesis_prompt(&self, gap: &CapabilityGap, template: &SynthesisTemplate) -> String {
        match gap {
            CapabilityGap::Mcp { name, purpose, api_hint } => {
                format!(
                    r#"Generate a complete, working MCP (Model Context Protocol) server implementation.

**Name**: {name}
**Purpose**: {purpose}
**API Hint**: {api_hint}
**Language**: {lang}

Use this template as a starting point:

```{lang}
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Implement the actual API call logic
3. Add proper error handling
4. Add input validation
5. Use environment variables for API keys (never hardcode)
6. Add TypeScript types where appropriate

Return ONLY the complete implementation code, no explanations."#,
                    name = name,
                    purpose = purpose,
                    api_hint = api_hint.as_deref().unwrap_or("none provided"),
                    lang = template.language,
                    template = template.content
                )
            }
            CapabilityGap::Skill { name, trigger, purpose } => {
                format!(
                    r#"Generate a complete SKILL.md file for Claude Code.

**Name**: {name}
**Trigger**: {trigger}
**Purpose**: {purpose}

Use this template as a starting point:

```markdown
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Add comprehensive instructions
3. Include multiple examples
4. Add edge case handling
5. Make it immediately usable

Return ONLY the complete SKILL.md content, no explanations."#,
                    name = name,
                    trigger = trigger,
                    purpose = purpose,
                    template = template.content
                )
            }
            CapabilityGap::Agent { name, specialization } => {
                format!(
                    r#"Generate a complete AGENT.md file for Claude Code.

**Name**: {name}
**Specialization**: {specialization}

Use this template as a starting point:

```markdown
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Define clear capabilities
3. Add execution instructions
4. Include handoff criteria
5. Make it immediately usable

Return ONLY the complete AGENT.md content, no explanations."#,
                    name = name,
                    specialization = specialization,
                    template = template.content
                )
            }
            CapabilityGap::Hook { name, event, matcher, purpose } => {
                format!(
                    r#"Generate a complete shell script hook for Claude Code.

**Name**: {name}
**Event**: {event:?}
**Matcher**: {matcher}
**Purpose**: {purpose}

Use this template as a starting point:

```bash
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Implement the actual logic
3. Add proper error handling
4. Exit with 0 for success, non-zero for failure
5. Output any warnings/errors to stderr
6. Keep the script focused on a single purpose
7. Make it executable and portable (bash-compatible)

Return ONLY the complete shell script content, no explanations."#,
                    name = name,
                    event = event,
                    matcher = matcher,
                    purpose = purpose,
                    template = template.content
                )
            }
        }
    }

    /// Call Claude CLI to generate content
    fn call_claude(&self, prompt: &str) -> anyhow::Result<String> {
        let mut cmd = Command::new("claude");
        cmd.arg("--print");
        cmd.arg("--dangerously-skip-permissions");

        if let Some(ref model) = self.claude_model {
            cmd.arg("--model").arg(model);
        }

        cmd.arg(prompt);

        let output = cmd.output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Claude CLI failed: {}", stderr));
        }

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    /// Apply template substitutions
    fn apply_template(&self, template: &str, gap: &CapabilityGap) -> String {
        let mut result = template.to_string();

        match gap {
            CapabilityGap::Mcp { name, purpose, api_hint } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{purpose}}", purpose);
                if let Some(hint) = api_hint {
                    result = result.replace("{{api_hint}}", hint);
                    result = result.replace("{{#if api_hint}}", "");
                    result = result.replace("{{/if}}", "");
                } else {
                    // Remove the api_hint block
                    let start = result.find("{{#if api_hint}}");
                    let end = result.find("{{/if}}");
                    if let (Some(s), Some(e)) = (start, end) {
                        result = format!("{}{}", &result[..s], &result[e + 7..]);
                    }
                }
            }
            CapabilityGap::Skill { name, trigger, purpose } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{NAME}}", name);
                result = result.replace("{{trigger}}", trigger);
                result = result.replace("{{TRIGGER}}", trigger);
                result = result.replace("{{purpose}}", purpose);
                result = result.replace("{{DESCRIPTION}}", purpose);
            }
            CapabilityGap::Agent { name, specialization } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{specialization}}", specialization);
            }
            CapabilityGap::Hook { name, event, matcher, purpose } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{event}}", event.as_str());
                result = result.replace("{{matcher}}", matcher);
                result = result.replace("{{purpose}}", purpose);
            }
        }

        result
    }

    /// Synthesize an MCP capability
    pub async fn synthesize_mcp(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let mcp_dir = self.output_dir.join("mcps").join(name);
        std::fs::create_dir_all(&mcp_dir)?;

        let template = self.templates.get(TemplateType::McpHttp)
            .ok_or_else(|| anyhow::anyhow!("MCP HTTP template not found"))?;

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract code from markdown code blocks if present
                    let code = extract_code_block(&output);
                    (code, true, Some(output))
                }
                Err(e) => {
                    // Fall back to template
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        // Write main file
        let main_file = mcp_dir.join("index.ts");
        std::fs::write(&main_file, &content)?;

        // Write package.json
        let package_json = format!(
            r#"{{
  "name": "mcp-{name}",
  "version": "1.0.0",
  "description": "MCP server for {name}",
  "main": "index.ts",
  "scripts": {{
    "start": "npx ts-node index.ts"
  }},
  "dependencies": {{
    "@modelcontextprotocol/sdk": "^1.0.0"
  }},
  "devDependencies": {{
    "typescript": "^5.0.0",
    "ts-node": "^10.9.0",
    "@types/node": "^20.0.0"
  }}
}}"#,
            name = name
        );
        std::fs::write(mcp_dir.join("package.json"), package_json)?;

        let capability = SynthesizedCapability::new(CapabilityType::Mcp, name, mcp_dir.clone())
            .with_config(serde_json::json!({
                "command": "npx",
                "args": ["ts-node", main_file.to_string_lossy()]
            }));

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize a skill capability
    pub async fn synthesize_skill(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let skills_dir = self.output_dir.join("skills");
        std::fs::create_dir_all(&skills_dir)?;

        let template = self.templates.get(TemplateType::SkillGeneric)
            .ok_or_else(|| anyhow::anyhow!("Skill template not found"))?;

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract markdown if wrapped in code blocks
                    let md = extract_markdown_block(&output);
                    (md, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        let skill_path = skills_dir.join(format!("{}.SKILL.md", name));
        std::fs::write(&skill_path, &content)?;

        let capability = SynthesizedCapability::new(CapabilityType::Skill, name, skill_path);

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize an agent capability
    pub async fn synthesize_agent(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let agents_dir = self.output_dir.join("agents");
        std::fs::create_dir_all(&agents_dir)?;

        // Get the specialization for domain-specific template selection
        let specialization = if let CapabilityGap::Agent { specialization, .. } = gap {
            specialization.as_str()
        } else {
            ""
        };

        // Try to find a specialized template based on domain keywords
        let specialized_template = get_specialized_agent_template(specialization)
            .or_else(|| get_specialized_agent_template(name));

        let template = self.templates.get(TemplateType::AgentGeneric)
            .ok_or_else(|| anyhow::anyhow!("Agent template not found"))?;

        // Use specialized template if available, otherwise use generic
        let base_template = specialized_template.unwrap_or(&template.content);

        let (content, used_claude, claude_output) = if self.use_claude {
            // Create a temporary template with the specialized content
            let temp_template = SynthesisTemplate {
                template_type: TemplateType::AgentGeneric,
                name: "agent-specialized".to_string(),
                content: base_template.to_string(),
                language: "markdown".to_string(),
            };
            let prompt = self.generate_agent_synthesis_prompt(gap, &temp_template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    let md = extract_markdown_block(&output);
                    (md, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(base_template, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(base_template, gap);
            (content, false, None)
        };

        let agent_path = agents_dir.join(format!("{}.AGENT.md", name));
        std::fs::write(&agent_path, &content)?;

        let capability = SynthesizedCapability::new(CapabilityType::Agent, name, agent_path);

        let mut notes = vec![];
        if used_claude {
            notes.push("Generated with Claude".to_string());
        } else {
            notes.push("Generated from template".to_string());
        }
        if specialized_template.is_some() {
            notes.push(format!("Used specialized {} template", specialization));
        }

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                let temp_template = SynthesisTemplate {
                    template_type: TemplateType::AgentGeneric,
                    name: "agent-specialized".to_string(),
                    content: base_template.to_string(),
                    language: "markdown".to_string(),
                };
                self.generate_agent_synthesis_prompt(gap, &temp_template)
            } else {
                String::new()
            },
            claude_output,
            notes,
        })
    }

    /// Generate specialized agent synthesis prompt with enhanced instructions
    fn generate_agent_synthesis_prompt(&self, gap: &CapabilityGap, template: &SynthesisTemplate) -> String {
        if let CapabilityGap::Agent { name, specialization } = gap {
            format!(
                r#"Generate a comprehensive, production-ready AGENT.md file for Claude Code.

**Name**: {name}
**Specialization**: {specialization}

Use this template as your base, but enhance it significantly:

```markdown
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Add SPECIFIC instructions for the specialization domain
3. Include concrete examples relevant to the specialization
4. Add domain-specific verification steps
5. Include common patterns and anti-patterns for this domain
6. Add integration points with other agents/systems
7. Make the agent immediately useful for real tasks

The agent should embody deep expertise in {specialization} and be able to:
- Execute tasks autonomously within its domain
- Coordinate with other specialized agents
- Verify its own work thoroughly
- Handle edge cases intelligently

Return ONLY the complete AGENT.md content, no explanations."#,
                name = name,
                specialization = specialization,
                template = template.content
            )
        } else {
            self.generate_synthesis_prompt(gap, template)
        }
    }

    /// Synthesize a hook capability
    pub async fn synthesize_hook(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let hooks_dir = self.output_dir.join("hooks");
        std::fs::create_dir_all(&hooks_dir)?;

        // Get hook-specific info from gap
        let (event, matcher) = if let CapabilityGap::Hook { event, matcher, .. } = gap {
            (event.as_str().to_string(), matcher.clone())
        } else {
            ("PreToolUse".to_string(), "*".to_string())
        };

        // Create a basic hook template
        let default_template = r#"#!/bin/bash
# {{name}} hook
# Event: {{event}}
# Matcher: {{matcher}}
# Purpose: {{purpose}}

set -e

# Add your hook logic here

exit 0
"#;

        let template = SynthesisTemplate {
            name: "hook".to_string(),
            template_type: TemplateType::SkillGeneric, // Reuse skill type for now
            language: "bash".to_string(),
            content: default_template.to_string(),
        };

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, &template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract bash code from markdown code blocks if present
                    let code = extract_code_block(&output);
                    (code, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        let hook_path = hooks_dir.join(format!("{}.sh", name));
        std::fs::write(&hook_path, &content)?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&hook_path, perms)?;
        }

        let mut capability = SynthesizedCapability::new(CapabilityType::Hook, name, hook_path);
        capability.config = serde_json::json!({
            "event": event,
            "matcher": matcher
        });

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, &template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize a capability based on gap type
    pub async fn synthesize(&self, gap: &CapabilityGap) -> anyhow::Result<SynthesisResult> {
        match gap {
            CapabilityGap::Mcp { .. } => self.synthesize_mcp(gap).await,
            CapabilityGap::Skill { .. } => self.synthesize_skill(gap).await,
            CapabilityGap::Agent { .. } => self.synthesize_agent(gap).await,
            CapabilityGap::Hook { .. } => self.synthesize_hook(gap).await,
        }
    }

    /// Get the working directory
    pub fn working_dir(&self) -> &PathBuf {
        &self.working_dir
    }

    /// Get the output directory
    pub fn output_dir(&self) -> &PathBuf {
        &self.output_dir
    }

    /// Get template registry
    pub fn templates(&self) -> &TemplateRegistry {
        &self.templates
    }
}

/// Extract code block from markdown output
fn extract_code_block(content: &str) -> String {
    // Look for typescript/javascript code blocks
    for lang in ["typescript", "ts", "javascript", "js", ""] {
        let start_marker = format!("```{}", lang);
        if let Some(start) = content.find(&start_marker) {
            let code_start = start + start_marker.len();
            // Skip the newline after the marker
            let code_start = content[code_start..].find('\n')
                .map(|i| code_start + i + 1)
                .unwrap_or(code_start);

            if let Some(end) = content[code_start..].find("```") {
                return content[code_start..code_start + end].trim().to_string();
            }
        }
    }

    // No code block found, return as-is
    content.trim().to_string()
}

/// Extract markdown block from output
fn extract_markdown_block(content: &str) -> String {
    // Look for markdown code blocks
    let start_marker = "```markdown";
    if let Some(start) = content.find(start_marker) {
        let md_start = start + start_marker.len();
        let md_start = content[md_start..].find('\n')
            .map(|i| md_start + i + 1)
            .unwrap_or(md_start);

        if let Some(end) = content.rfind("```") {
            if end > md_start {
                return content[md_start..end].trim().to_string();
            }
        }
    }

    // Also try ```md
    let start_marker = "```md";
    if let Some(start) = content.find(start_marker) {
        let md_start = start + start_marker.len();
        let md_start = content[md_start..].find('\n')
            .map(|i| md_start + i + 1)
            .unwrap_or(md_start);

        if let Some(end) = content.rfind("```") {
            if end > md_start {
                return content[md_start..end].trim().to_string();
            }
        }
    }

    // No markdown block found, return as-is
    content.trim().to_string()
}

/// Get home directory
fn dirs_home() -> Option<PathBuf> {
    std::env::var("HOME")
        .ok()
        .map(PathBuf::from)
        .or_else(|| std::env::var("USERPROFILE").ok().map(PathBuf::from))
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_synthesis_engine_new() {
        let engine = SynthesisEngine::default();
        assert_eq!(engine.mcp_language, "typescript");
        assert!(engine.use_claude);
    }

    #[test]
    fn test_with_working_dir() {
        let engine = SynthesisEngine::default().with_working_dir(PathBuf::from("/tmp/test"));
        assert_eq!(engine.working_dir, PathBuf::from("/tmp/test"));
    }

    #[test]
    fn test_with_claude() {
        let engine = SynthesisEngine::default().with_claude(false);
        assert!(!engine.use_claude);
    }

    #[test]
    fn test_template_registry_new() {
        let registry = TemplateRegistry::new();
        assert!(!registry.templates.is_empty());
        assert!(registry.get(TemplateType::McpHttp).is_some());
        assert!(registry.get(TemplateType::SkillGeneric).is_some());
    }

    #[test]
    fn test_apply_template_mcp() {
        let engine = SynthesisEngine::default();
        let gap = CapabilityGap::Mcp {
            name: "github-api".to_string(),
            purpose: "Access GitHub repositories".to_string(),
            api_hint: Some("https://api.github.com".to_string()),
        };

        let template = engine.templates.get(TemplateType::McpHttp).unwrap();
        let result = engine.apply_template(&template.content, &gap);

        assert!(result.contains("github-api"));
        assert!(result.contains("Access GitHub repositories"));
    }

    #[test]
    fn test_apply_template_skill() {
        let engine = SynthesisEngine::default();
        let gap = CapabilityGap::Skill {
            name: "code-review".to_string(),
            trigger: "/review".to_string(),
            purpose: "Automated code review".to_string(),
        };

        let template = engine.templates.get(TemplateType::SkillGeneric).unwrap();
        let result = engine.apply_template(&template.content, &gap);

        assert!(result.contains("code-review"));
        assert!(result.contains("/review"));
    }

    #[test]
    fn test_extract_code_block() {
        let content = r#"Here's the code:

```typescript
const x = 1;
const y = 2;
```

That's all."#;

        let extracted = extract_code_block(content);
        assert_eq!(extracted, "const x = 1;\nconst y = 2;");
    }

    #[test]
    fn test_extract_code_block_no_block() {
        let content = "Just plain text without code blocks";
        let extracted = extract_code_block(content);
        assert_eq!(extracted, content);
    }

    #[test]
    fn test_extract_markdown_block() {
        let content = r#"Here's the markdown:

```markdown
# Title

Some content
```

Done."#;

        let extracted = extract_markdown_block(content);
        assert_eq!(extracted, "# Title\n\nSome content");
    }

    #[test]
    fn test_extract_markdown_block_with_inner_fences() {
        let content = r#"```markdown
# Title

Example:
```
echo "hi"
```

## Notes
Done.
```"#;

        let extracted = extract_markdown_block(content);
        assert!(extracted.contains("Example:"));
        assert!(extracted.contains("```"));
        assert!(extracted.contains("## Notes"));
    }

    #[tokio::test]
    async fn test_synthesize_skill_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Skill {
            name: "test-skill".to_string(),
            trigger: "/test".to_string(),
            purpose: "Testing skill synthesis".to_string(),
        };

        let result = engine.synthesize_skill(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());
        assert_eq!(result.capability.name, "test-skill");

        let content = std::fs::read_to_string(&result.capability.path).unwrap();
        assert!(content.contains("test-skill"));
        assert!(content.contains("/test"));
    }

    #[tokio::test]
    async fn test_synthesize_mcp_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Mcp {
            name: "test-api".to_string(),
            purpose: "Test API integration".to_string(),
            api_hint: None,
        };

        let result = engine.synthesize_mcp(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());
        assert!(result.capability.path.join("index.ts").exists());
        assert!(result.capability.path.join("package.json").exists());
    }

    #[tokio::test]
    async fn test_synthesize_agent_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Agent {
            name: "test-agent".to_string(),
            specialization: "Test specialization".to_string(),
        };

        let result = engine.synthesize_agent(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());

        let content = std::fs::read_to_string(&result.capability.path).unwrap();
        assert!(content.contains("test-agent"));
        assert!(content.contains("Test specialization"));
    }
}
