//! Synthesis Engine Module
//!
//! Generates new capabilities from gap descriptions.
//! Uses Claude to generate the capability, with templates/scaffolding.

use super::{CapabilityGap, CapabilityType, SynthesizedCapability};
use serde::{Deserialize, Serialize};
use std::path::PathBuf;
use std::process::Command;

/// Template type for synthesis
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum TemplateType {
    /// HTTP API MCP template
    McpHttp,
    /// File-based MCP template
    McpFile,
    /// Database MCP template
    McpDatabase,
    /// Generic skill template
    SkillGeneric,
    /// Agent template
    AgentGeneric,
}

/// Template for capability synthesis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynthesisTemplate {
    /// Template type
    pub template_type: TemplateType,
    /// Template name
    pub name: String,
    /// Template content
    pub content: String,
    /// Language (TypeScript, Python, Markdown)
    pub language: String,
}

/// Registry of synthesis templates
#[derive(Debug, Clone, Default)]
pub struct TemplateRegistry {
    templates: Vec<SynthesisTemplate>,
}

impl TemplateRegistry {
    /// Create a new template registry with defaults
    pub fn new() -> Self {
        Self {
            templates: Self::default_templates(),
        }
    }

    /// Get default templates
    fn default_templates() -> Vec<SynthesisTemplate> {
        vec![
            SynthesisTemplate {
                template_type: TemplateType::McpHttp,
                name: "mcp-http".to_string(),
                content: MCP_HTTP_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::McpFile,
                name: "mcp-file".to_string(),
                content: MCP_FILE_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::McpDatabase,
                name: "mcp-database".to_string(),
                content: MCP_DATABASE_TEMPLATE.to_string(),
                language: "typescript".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::SkillGeneric,
                name: "skill-generic".to_string(),
                content: SKILL_GENERIC_TEMPLATE.to_string(),
                language: "markdown".to_string(),
            },
            SynthesisTemplate {
                template_type: TemplateType::AgentGeneric,
                name: "agent-generic".to_string(),
                content: AGENT_GENERIC_TEMPLATE.to_string(),
                language: "markdown".to_string(),
            },
        ]
    }

    /// Get template by type
    pub fn get(&self, template_type: TemplateType) -> Option<&SynthesisTemplate> {
        self.templates
            .iter()
            .find(|t| t.template_type == template_type)
    }

    /// Add a custom template
    pub fn add(&mut self, template: SynthesisTemplate) {
        self.templates.push(template);
    }

    /// Get all templates
    pub fn all(&self) -> &[SynthesisTemplate] {
        &self.templates
    }
}

/// MCP HTTP template content
const MCP_HTTP_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

// List available tools
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_action",
        description: "{{purpose}}",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "The query or action to perform",
            },
          },
          required: ["query"],
        },
      },
    ],
  };
});

// Handle tool calls
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "{{name}}_action") {
    // TODO: Implement actual API call logic here
    const query = args?.query as string;

    try {
      // Replace with actual API implementation
      const result = await performAction(query);
      return {
        content: [{ type: "text", text: JSON.stringify(result, null, 2) }],
      };
    } catch (error) {
      return {
        content: [{ type: "text", text: `Error: ${error}` }],
        isError: true,
      };
    }
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function performAction(query: string): Promise<unknown> {
  // TODO: Implement the actual API call
  {{#if api_hint}}
  // API hint: {{api_hint}}
  {{/if}}
  return { status: "not_implemented", query };
}

// Start the server
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("{{name}} MCP server running on stdio");
}

main().catch(console.error);
"#;

/// MCP File template content
const MCP_FILE_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: File-based operations for {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import * as fs from "fs/promises";
import * as path from "path";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_read",
        description: "Read file content",
        inputSchema: {
          type: "object",
          properties: {
            path: { type: "string", description: "File path" },
          },
          required: ["path"],
        },
      },
      {
        name: "{{name}}_write",
        description: "Write file content",
        inputSchema: {
          type: "object",
          properties: {
            path: { type: "string", description: "File path" },
            content: { type: "string", description: "Content to write" },
          },
          required: ["path", "content"],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  try {
    if (name === "{{name}}_read") {
      const content = await fs.readFile(args?.path as string, "utf-8");
      return { content: [{ type: "text", text: content }] };
    }

    if (name === "{{name}}_write") {
      await fs.writeFile(args?.path as string, args?.content as string);
      return { content: [{ type: "text", text: "File written successfully" }] };
    }
  } catch (error) {
    return { content: [{ type: "text", text: `Error: ${error}` }], isError: true };
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch(console.error);
"#;

/// MCP Database template content
const MCP_DATABASE_TEMPLATE: &str = r#"#!/usr/bin/env npx ts-node
// MCP Server: {{name}}
// Purpose: Database operations for {{purpose}}
// Generated by gogo-gadget self-extend

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";

const server = new Server(
  { name: "{{name}}", version: "1.0.0" },
  { capabilities: { tools: {} } }
);

server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "{{name}}_query",
        description: "Execute a database query",
        inputSchema: {
          type: "object",
          properties: {
            sql: { type: "string", description: "SQL query to execute" },
          },
          required: ["sql"],
        },
      },
    ],
  };
});

server.setRequestHandler(CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;

  if (name === "{{name}}_query") {
    // TODO: Implement database connection and query execution
    const sql = args?.sql as string;
    return {
      content: [{ type: "text", text: `Query executed: ${sql}` }],
    };
  }

  throw new Error(`Unknown tool: ${name}`);
});

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch(console.error);
"#;

/// Skill generic template content
const SKILL_GENERIC_TEMPLATE: &str = r#"# {{name}}

> {{purpose}}

## Trigger

Use when the user asks about {{trigger}} or mentions:
- "{{trigger}}"
- Related keywords

## Instructions

1. **Analyze the Request**
   - Understand what the user is asking for
   - Identify the specific action needed

2. **Execute the Action**
   - Perform the required operation
   - Handle any errors gracefully

3. **Return Results**
   - Provide clear, actionable output
   - Include any relevant context

## Examples

### Example 1
**User**: "{{trigger}}"
**Action**: Execute the primary action
**Result**: Return formatted results

## Notes

- This skill was auto-generated by gogo-gadget self-extend
- Created for: {{purpose}}
"#;

/// Agent generic template content
const AGENT_GENERIC_TEMPLATE: &str = r#"# {{name}} Agent

> Specialized agent for: {{specialization}}

## Capabilities

This agent is designed to handle:
- {{specialization}}
- Related subtasks

## Execution Mode

- **Type**: Autonomous
- **Focus**: {{specialization}}

## Instructions

When invoked, this agent will:

1. Analyze the task requirements
2. Break down complex tasks into subtasks
3. Execute each subtask methodically
4. Verify completion before reporting

## Handoff Criteria

Hand off to this agent when:
- The task involves {{specialization}}
- Specialized knowledge is required
- The main agent lacks the capability

## Notes

- Auto-generated by gogo-gadget self-extend
- Version: 1.0.0
"#;

/// Result of a synthesis operation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SynthesisResult {
    /// The synthesized capability
    pub capability: SynthesizedCapability,
    /// Whether Claude was used for generation
    pub used_claude: bool,
    /// Generation prompt used
    pub prompt: String,
    /// Raw output from Claude (if used)
    pub claude_output: Option<String>,
    /// Warnings or notes from synthesis
    pub notes: Vec<String>,
}

/// Engine for synthesizing new capabilities
#[derive(Debug, Clone)]
pub struct SynthesisEngine {
    /// Template registry
    templates: TemplateRegistry,
    /// Working directory for synthesis
    working_dir: PathBuf,
    /// Preferred language for MCP synthesis
    mcp_language: String,
    /// Whether to use Claude for synthesis
    use_claude: bool,
    /// Claude model to use
    claude_model: Option<String>,
    /// Output directory for synthesized capabilities
    output_dir: PathBuf,
}

impl Default for SynthesisEngine {
    fn default() -> Self {
        Self::new_default()
    }
}

impl SynthesisEngine {
    /// Create a new synthesis engine with a specific output directory
    pub fn new(output_dir: &PathBuf) -> Self {
        Self {
            templates: TemplateRegistry::new(),
            working_dir: std::env::temp_dir().join("gogo-gadget-synthesis"),
            mcp_language: "typescript".to_string(),
            use_claude: true,
            claude_model: None,
            output_dir: output_dir.clone(),
        }
    }

    /// Create a new synthesis engine with default output directory
    pub fn new_default() -> Self {
        let home = dirs_home().unwrap_or_else(|| PathBuf::from("."));
        Self {
            templates: TemplateRegistry::new(),
            working_dir: std::env::temp_dir().join("gogo-gadget-synthesis"),
            mcp_language: "typescript".to_string(),
            use_claude: true,
            claude_model: None,
            output_dir: home.join(".gogo-gadget").join("synthesized"),
        }
    }

    /// Create with custom working directory
    pub fn with_working_dir(mut self, dir: PathBuf) -> Self {
        self.working_dir = dir;
        self
    }

    /// Set MCP language preference
    pub fn with_mcp_language(mut self, lang: impl Into<String>) -> Self {
        self.mcp_language = lang.into();
        self
    }

    /// Set whether to use Claude for synthesis
    pub fn with_claude(mut self, use_claude: bool) -> Self {
        self.use_claude = use_claude;
        self
    }

    /// Set Claude model
    pub fn with_model(mut self, model: impl Into<String>) -> Self {
        self.claude_model = Some(model.into());
        self
    }

    /// Set output directory
    pub fn with_output_dir(mut self, dir: PathBuf) -> Self {
        self.output_dir = dir;
        self
    }

    /// Generate synthesis prompt for Claude
    fn generate_synthesis_prompt(&self, gap: &CapabilityGap, template: &SynthesisTemplate) -> String {
        match gap {
            CapabilityGap::Mcp { name, purpose, api_hint } => {
                format!(
                    r#"Generate a complete, working MCP (Model Context Protocol) server implementation.

**Name**: {name}
**Purpose**: {purpose}
**API Hint**: {api_hint}
**Language**: {lang}

Use this template as a starting point:

```{lang}
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Implement the actual API call logic
3. Add proper error handling
4. Add input validation
5. Use environment variables for API keys (never hardcode)
6. Add TypeScript types where appropriate

Return ONLY the complete implementation code, no explanations."#,
                    name = name,
                    purpose = purpose,
                    api_hint = api_hint.as_deref().unwrap_or("none provided"),
                    lang = template.language,
                    template = template.content
                )
            }
            CapabilityGap::Skill { name, trigger, purpose } => {
                format!(
                    r#"Generate a complete SKILL.md file for Claude Code.

**Name**: {name}
**Trigger**: {trigger}
**Purpose**: {purpose}

Use this template as a starting point:

```markdown
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Add comprehensive instructions
3. Include multiple examples
4. Add edge case handling
5. Make it immediately usable

Return ONLY the complete SKILL.md content, no explanations."#,
                    name = name,
                    trigger = trigger,
                    purpose = purpose,
                    template = template.content
                )
            }
            CapabilityGap::Agent { name, specialization } => {
                format!(
                    r#"Generate a complete AGENT.md file for Claude Code.

**Name**: {name}
**Specialization**: {specialization}

Use this template as a starting point:

```markdown
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Define clear capabilities
3. Add execution instructions
4. Include handoff criteria
5. Make it immediately usable

Return ONLY the complete AGENT.md content, no explanations."#,
                    name = name,
                    specialization = specialization,
                    template = template.content
                )
            }
            CapabilityGap::Hook { name, event, matcher, purpose } => {
                format!(
                    r#"Generate a complete shell script hook for Claude Code.

**Name**: {name}
**Event**: {event:?}
**Matcher**: {matcher}
**Purpose**: {purpose}

Use this template as a starting point:

```bash
{template}
```

Requirements:
1. Replace all placeholder {{{{...}}}} with actual values
2. Implement the actual logic
3. Add proper error handling
4. Exit with 0 for success, non-zero for failure
5. Output any warnings/errors to stderr
6. Keep the script focused on a single purpose
7. Make it executable and portable (bash-compatible)

Return ONLY the complete shell script content, no explanations."#,
                    name = name,
                    event = event,
                    matcher = matcher,
                    purpose = purpose,
                    template = template.content
                )
            }
        }
    }

    /// Call Claude CLI to generate content
    fn call_claude(&self, prompt: &str) -> anyhow::Result<String> {
        let mut cmd = Command::new("claude");
        cmd.arg("--print");
        cmd.arg("--dangerously-skip-permissions");

        if let Some(ref model) = self.claude_model {
            cmd.arg("--model").arg(model);
        }

        cmd.arg(prompt);

        let output = cmd.output()?;

        if !output.status.success() {
            let stderr = String::from_utf8_lossy(&output.stderr);
            return Err(anyhow::anyhow!("Claude CLI failed: {}", stderr));
        }

        Ok(String::from_utf8_lossy(&output.stdout).to_string())
    }

    /// Apply template substitutions
    fn apply_template(&self, template: &str, gap: &CapabilityGap) -> String {
        let mut result = template.to_string();

        match gap {
            CapabilityGap::Mcp { name, purpose, api_hint } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{purpose}}", purpose);
                if let Some(hint) = api_hint {
                    result = result.replace("{{api_hint}}", hint);
                    result = result.replace("{{#if api_hint}}", "");
                    result = result.replace("{{/if}}", "");
                } else {
                    // Remove the api_hint block
                    let start = result.find("{{#if api_hint}}");
                    let end = result.find("{{/if}}");
                    if let (Some(s), Some(e)) = (start, end) {
                        result = format!("{}{}", &result[..s], &result[e + 7..]);
                    }
                }
            }
            CapabilityGap::Skill { name, trigger, purpose } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{trigger}}", trigger);
                result = result.replace("{{purpose}}", purpose);
            }
            CapabilityGap::Agent { name, specialization } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{specialization}}", specialization);
            }
            CapabilityGap::Hook { name, event, matcher, purpose } => {
                result = result.replace("{{name}}", name);
                result = result.replace("{{event}}", event.as_str());
                result = result.replace("{{matcher}}", matcher);
                result = result.replace("{{purpose}}", purpose);
            }
        }

        result
    }

    /// Synthesize an MCP capability
    pub async fn synthesize_mcp(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let mcp_dir = self.output_dir.join("mcps").join(name);
        std::fs::create_dir_all(&mcp_dir)?;

        let template = self.templates.get(TemplateType::McpHttp)
            .ok_or_else(|| anyhow::anyhow!("MCP HTTP template not found"))?;

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract code from markdown code blocks if present
                    let code = extract_code_block(&output);
                    (code, true, Some(output))
                }
                Err(e) => {
                    // Fall back to template
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        // Write main file
        let main_file = mcp_dir.join("index.ts");
        std::fs::write(&main_file, &content)?;

        // Write package.json
        let package_json = format!(
            r#"{{
  "name": "mcp-{name}",
  "version": "1.0.0",
  "description": "MCP server for {name}",
  "main": "index.ts",
  "scripts": {{
    "start": "npx ts-node index.ts"
  }},
  "dependencies": {{
    "@modelcontextprotocol/sdk": "^1.0.0"
  }},
  "devDependencies": {{
    "typescript": "^5.0.0",
    "ts-node": "^10.9.0",
    "@types/node": "^20.0.0"
  }}
}}"#,
            name = name
        );
        std::fs::write(mcp_dir.join("package.json"), package_json)?;

        let capability = SynthesizedCapability::new(CapabilityType::Mcp, name, mcp_dir.clone())
            .with_config(serde_json::json!({
                "command": "npx",
                "args": ["ts-node", main_file.to_string_lossy()]
            }));

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize a skill capability
    pub async fn synthesize_skill(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let skills_dir = self.output_dir.join("skills");
        std::fs::create_dir_all(&skills_dir)?;

        let template = self.templates.get(TemplateType::SkillGeneric)
            .ok_or_else(|| anyhow::anyhow!("Skill template not found"))?;

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract markdown if wrapped in code blocks
                    let md = extract_markdown_block(&output);
                    (md, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        let skill_path = skills_dir.join(format!("{}.SKILL.md", name));
        std::fs::write(&skill_path, &content)?;

        let capability = SynthesizedCapability::new(CapabilityType::Skill, name, skill_path);

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize an agent capability
    pub async fn synthesize_agent(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let agents_dir = self.output_dir.join("agents");
        std::fs::create_dir_all(&agents_dir)?;

        let template = self.templates.get(TemplateType::AgentGeneric)
            .ok_or_else(|| anyhow::anyhow!("Agent template not found"))?;

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    let md = extract_markdown_block(&output);
                    (md, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        let agent_path = agents_dir.join(format!("{}.AGENT.md", name));
        std::fs::write(&agent_path, &content)?;

        let capability = SynthesizedCapability::new(CapabilityType::Agent, name, agent_path);

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize a hook capability
    pub async fn synthesize_hook(
        &self,
        gap: &CapabilityGap,
    ) -> anyhow::Result<SynthesisResult> {
        let name = gap.name();
        let hooks_dir = self.output_dir.join("hooks");
        std::fs::create_dir_all(&hooks_dir)?;

        // Get hook-specific info from gap
        let (event, matcher) = if let CapabilityGap::Hook { event, matcher, .. } = gap {
            (event.as_str().to_string(), matcher.clone())
        } else {
            ("PreToolUse".to_string(), "*".to_string())
        };

        // Create a basic hook template
        let default_template = r#"#!/bin/bash
# {{name}} hook
# Event: {{event}}
# Matcher: {{matcher}}
# Purpose: {{purpose}}

set -e

# Add your hook logic here

exit 0
"#;

        let template = SynthesisTemplate {
            name: "hook".to_string(),
            template_type: TemplateType::SkillGeneric, // Reuse skill type for now
            language: "bash".to_string(),
            content: default_template.to_string(),
        };

        let (content, used_claude, claude_output) = if self.use_claude {
            let prompt = self.generate_synthesis_prompt(gap, &template);
            match self.call_claude(&prompt) {
                Ok(output) => {
                    // Extract bash code from markdown code blocks if present
                    let code = extract_code_block(&output);
                    (code, true, Some(output))
                }
                Err(e) => {
                    let content = self.apply_template(&template.content, gap);
                    (content, false, Some(format!("Claude failed: {}", e)))
                }
            }
        } else {
            let content = self.apply_template(&template.content, gap);
            (content, false, None)
        };

        let hook_path = hooks_dir.join(format!("{}.sh", name));
        std::fs::write(&hook_path, &content)?;

        // Make executable on Unix
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            let mut perms = std::fs::metadata(&hook_path)?.permissions();
            perms.set_mode(0o755);
            std::fs::set_permissions(&hook_path, perms)?;
        }

        let mut capability = SynthesizedCapability::new(CapabilityType::Hook, name, hook_path);
        capability.config = serde_json::json!({
            "event": event,
            "matcher": matcher
        });

        Ok(SynthesisResult {
            capability,
            used_claude,
            prompt: if self.use_claude {
                self.generate_synthesis_prompt(gap, &template)
            } else {
                String::new()
            },
            claude_output,
            notes: if used_claude {
                vec!["Generated with Claude".to_string()]
            } else {
                vec!["Generated from template".to_string()]
            },
        })
    }

    /// Synthesize a capability based on gap type
    pub async fn synthesize(&self, gap: &CapabilityGap) -> anyhow::Result<SynthesisResult> {
        match gap {
            CapabilityGap::Mcp { .. } => self.synthesize_mcp(gap).await,
            CapabilityGap::Skill { .. } => self.synthesize_skill(gap).await,
            CapabilityGap::Agent { .. } => self.synthesize_agent(gap).await,
            CapabilityGap::Hook { .. } => self.synthesize_hook(gap).await,
        }
    }

    /// Get the working directory
    pub fn working_dir(&self) -> &PathBuf {
        &self.working_dir
    }

    /// Get the output directory
    pub fn output_dir(&self) -> &PathBuf {
        &self.output_dir
    }

    /// Get template registry
    pub fn templates(&self) -> &TemplateRegistry {
        &self.templates
    }
}

/// Extract code block from markdown output
fn extract_code_block(content: &str) -> String {
    // Look for typescript/javascript code blocks
    for lang in ["typescript", "ts", "javascript", "js", ""] {
        let start_marker = format!("```{}", lang);
        if let Some(start) = content.find(&start_marker) {
            let code_start = start + start_marker.len();
            // Skip the newline after the marker
            let code_start = content[code_start..].find('\n')
                .map(|i| code_start + i + 1)
                .unwrap_or(code_start);

            if let Some(end) = content[code_start..].find("```") {
                return content[code_start..code_start + end].trim().to_string();
            }
        }
    }

    // No code block found, return as-is
    content.trim().to_string()
}

/// Extract markdown block from output
fn extract_markdown_block(content: &str) -> String {
    // Look for markdown code blocks
    let start_marker = "```markdown";
    if let Some(start) = content.find(start_marker) {
        let md_start = start + start_marker.len();
        let md_start = content[md_start..].find('\n')
            .map(|i| md_start + i + 1)
            .unwrap_or(md_start);

        if let Some(end) = content[md_start..].find("```") {
            return content[md_start..md_start + end].trim().to_string();
        }
    }

    // Also try ```md
    let start_marker = "```md";
    if let Some(start) = content.find(start_marker) {
        let md_start = start + start_marker.len();
        let md_start = content[md_start..].find('\n')
            .map(|i| md_start + i + 1)
            .unwrap_or(md_start);

        if let Some(end) = content[md_start..].find("```") {
            return content[md_start..md_start + end].trim().to_string();
        }
    }

    // No markdown block found, return as-is
    content.trim().to_string()
}

/// Get home directory
fn dirs_home() -> Option<PathBuf> {
    std::env::var("HOME")
        .ok()
        .map(PathBuf::from)
        .or_else(|| std::env::var("USERPROFILE").ok().map(PathBuf::from))
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_synthesis_engine_new() {
        let engine = SynthesisEngine::default();
        assert_eq!(engine.mcp_language, "typescript");
        assert!(engine.use_claude);
    }

    #[test]
    fn test_with_working_dir() {
        let engine = SynthesisEngine::default().with_working_dir(PathBuf::from("/tmp/test"));
        assert_eq!(engine.working_dir, PathBuf::from("/tmp/test"));
    }

    #[test]
    fn test_with_claude() {
        let engine = SynthesisEngine::default().with_claude(false);
        assert!(!engine.use_claude);
    }

    #[test]
    fn test_template_registry_new() {
        let registry = TemplateRegistry::new();
        assert!(!registry.templates.is_empty());
        assert!(registry.get(TemplateType::McpHttp).is_some());
        assert!(registry.get(TemplateType::SkillGeneric).is_some());
    }

    #[test]
    fn test_apply_template_mcp() {
        let engine = SynthesisEngine::default();
        let gap = CapabilityGap::Mcp {
            name: "github-api".to_string(),
            purpose: "Access GitHub repositories".to_string(),
            api_hint: Some("https://api.github.com".to_string()),
        };

        let template = engine.templates.get(TemplateType::McpHttp).unwrap();
        let result = engine.apply_template(&template.content, &gap);

        assert!(result.contains("github-api"));
        assert!(result.contains("Access GitHub repositories"));
    }

    #[test]
    fn test_apply_template_skill() {
        let engine = SynthesisEngine::default();
        let gap = CapabilityGap::Skill {
            name: "code-review".to_string(),
            trigger: "/review".to_string(),
            purpose: "Automated code review".to_string(),
        };

        let template = engine.templates.get(TemplateType::SkillGeneric).unwrap();
        let result = engine.apply_template(&template.content, &gap);

        assert!(result.contains("code-review"));
        assert!(result.contains("/review"));
    }

    #[test]
    fn test_extract_code_block() {
        let content = r#"Here's the code:

```typescript
const x = 1;
const y = 2;
```

That's all."#;

        let extracted = extract_code_block(content);
        assert_eq!(extracted, "const x = 1;\nconst y = 2;");
    }

    #[test]
    fn test_extract_code_block_no_block() {
        let content = "Just plain text without code blocks";
        let extracted = extract_code_block(content);
        assert_eq!(extracted, content);
    }

    #[test]
    fn test_extract_markdown_block() {
        let content = r#"Here's the markdown:

```markdown
# Title

Some content
```

Done."#;

        let extracted = extract_markdown_block(content);
        assert_eq!(extracted, "# Title\n\nSome content");
    }

    #[tokio::test]
    async fn test_synthesize_skill_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Skill {
            name: "test-skill".to_string(),
            trigger: "/test".to_string(),
            purpose: "Testing skill synthesis".to_string(),
        };

        let result = engine.synthesize_skill(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());
        assert_eq!(result.capability.name, "test-skill");

        let content = std::fs::read_to_string(&result.capability.path).unwrap();
        assert!(content.contains("test-skill"));
        assert!(content.contains("/test"));
    }

    #[tokio::test]
    async fn test_synthesize_mcp_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Mcp {
            name: "test-api".to_string(),
            purpose: "Test API integration".to_string(),
            api_hint: None,
        };

        let result = engine.synthesize_mcp(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());
        assert!(result.capability.path.join("index.ts").exists());
        assert!(result.capability.path.join("package.json").exists());
    }

    #[tokio::test]
    async fn test_synthesize_agent_without_claude() {
        let temp_dir = TempDir::new().unwrap();
        let engine = SynthesisEngine::default()
            .with_output_dir(temp_dir.path().to_path_buf())
            .with_claude(false);

        let gap = CapabilityGap::Agent {
            name: "test-agent".to_string(),
            specialization: "Test specialization".to_string(),
        };

        let result = engine.synthesize_agent(&gap).await.unwrap();

        assert!(!result.used_claude);
        assert!(result.capability.path.exists());

        let content = std::fs::read_to_string(&result.capability.path).unwrap();
        assert!(content.contains("test-agent"));
        assert!(content.contains("Test specialization"));
    }
}
